n_false_positive = n_false_positive + 1
}
}
if (disease == 1){
diagnosis = rbinom(1,1, sens)
if (diagnosis == 1) {
n_total_positive = n_total_positive + 1
n_true_positive + n_true_positive + 1
}
}
}
print(n_total_positive)
print(n_true_positive)
print(n_false_positive)
print(n_false_positive / n_total_positive)
# 10.5 필터링조인
# install.packages("nycflights13")
library(nycflights13)
library(magrittr)
library(tidyverse)
# 예를 들어, 가장 인기 있는 상위 10개 도착지를 구했다고 가정해보자.
top_dest <- flights %>%
count(dest, sort = TRUE) %>%
head(10)
top_dest
# 이제 그 목적지 중 한 곳으로 운행한 항공편을 찾고 싶다면 직접 필터를 만들 수 있다
# 그러나 이러한 접근 방식을 여러 변수로 확장하는 것은 어렵다..
flights %>%
filter(dest %in% top_dest$dest)
# 뮤테이팅 조인과 같이 두 데이터프레임을 연결하는 세미 조인을 사용할 수 있지만,
# 새 열을 추가하는 대신 y 에서 일치하는 x 의 행만 보존한다.
flights %>%
semi_join(top_dest)
#세미조인의 반대는 안티조인
#예를 들어, 항공편과 여객기를 연결하는 경우, 여객기에 매치되지 않는 항공편이 많다는 것을 알고 싶을때
flights %>%
anti_join(planes, by = "tailnum") %>%
count(tailnum, sort = TRUE)
#세미조인의 반대는 안티조인
#예를 들어, 항공편과 여객기를 연결하는 경우, 여객기에 매치되지 않는 항공편이 많다는 것을 알고 싶을때
flights %>%
anti_join(planes, by = "tailnum") %>%
count(tailnum, sort = TRUE)
#10.5.1 연습문제
# 1.항공편에 tailnum 이 없는 것은 무엇을 의미하는가?
#   planes 에 매치되는 관측값이 없는 tailnum 관측값의 공통점은 무엇인가?
#   (힌트: 한 변수가 문제의 약 90%를 설명한다.)
#
# 누락된 항공편은 모두 누락된 값으로 항공편이 취소.
flights %>%
filter(is.na(tailnum), !is.na(arr_time)) %>%
nrow()
# 일치하는 값이 없는 꼬리 번호의 대부분은 MQ 또는 AA항공
flights %>%
anti_join(planes, by = "tailnum") %>%
count(carrier, sort = TRUE) %>%
mutate(p = n / sum(n))
flights %>%
distinct(carrier, tailnum) %>%
left_join(planes, by = "tailnum") %>%
group_by(carrier) %>%
summarise(total_planes = n(),
not_in_planes = sum(is.na(model))) %>%
mutate(missing_pct = not_in_planes / total_planes) %>%
arrange(desc(missing_pct))
# 2.flights 를 필터링하여 최소 100 편의 운행을 한 여객기의 항공편만 표시하라.
planes_gte100 <- flights %>%
filter(!is.na(tailnum)) %>%
group_by(tailnum) %>%
count() %>%
filter(n >= 100)
flights %>%
semi_join(planes_gte100, by = "tailnum")
flights %>%
filter(!is.na(tailnum)) %>%
group_by(tailnum) %>%
mutate(n = n()) %>%
filter(n >= 100)
# 3.fueleconomy::vehicles 와 fueleconomy::common 을 결합하여 가장 많은 차량 모델의 레코드만 찾아라.
# install.packages("fueleconomy")
library(fuelconomy)
install.packages("fueleconomy")
# 3.fueleconomy::vehicles 와 fueleconomy::common 을 결합하여 가장 많은 차량 모델의 레코드만 찾아라.
# install.packages("fueleconomy")
library(fuelconomy)
# 3.fueleconomy::vehicles 와 fueleconomy::common 을 결합하여 가장 많은 차량 모델의 레코드만 찾아라.
# install.packages("fueleconomy")
library(fueleconomy)
fueleconomy::vehicles %>%
semi_join(fueleconomy::common, by = c("make", "model"))
# 3.fueleconomy::vehicles 와 fueleconomy::common 을 결합하여 가장 많은 차량 모델의 레코드만 찾아라.
# install.packages("fueleconomy")
library(fueleconomy)
fueleconomy::vehicles %>%
semi_join(fueleconomy::common, by = c("make", "model"))
fueleconomy::vehicles %>%
distinct(model, make) %>%
group_by(model) %>%
filter(n() > 1) %>%
arrange(model)
fueleconomy::common %>%
distinct(model, make) %>%
group_by(model) %>%
filter(n() > 1) %>%
arrange(model)
# 3.fueleconomy::vehicles 와 fueleconomy::common 을 결합하여 가장 많은 차량 모델의 레코드만 찾아라.
# install.packages("fueleconomy")
library(fueleconomy)
fueleconomy::vehicles %>%
semi_join(fueleconomy::common, by = c("make", "model"))
fueleconomy::vehicles %>%
distinct(model, make) %>%
group_by(model) %>%
filter(n() > 1) %>%
arrange(model)
fueleconomy::common %>%
distinct(model, make) %>%
group_by(model) %>%
filter(n() > 1) %>%
arrange(model)
fueleconomy::common
# 10.6 조인 문제
# 데이터는 문제가 거의 발생하지 않도록 미리 정제되었다.
# 따라서 조인을 원활하게 하기 위해서 주어진 데이터에 수행해야 하는 몇 가지 작업이 있다.
#
# 1.우선 각 데이터프레임에서 기본키를 구성하는 변수들을 식별하라.
# 경험적이 아니라 데이터 이해를 바탕으로, 고유한 식별자가 되는 변수의 조합을 찾아야 한다.
#
# 예를 들어 고도(altitude)와 경도는 각 공항을 고유하게 식별하지만 좋은 식별자는 아니다!
#
airports %>% count(alt, lon) %>% filter(n > 1)
# 모든 연산은 행 전체에 동작하는데 모든 변수의 값을 비교한다.
# 이 집합 연산은 x 와 y 입력이 같은 변수를 가지는 것을 간주하며 관측값을 집합으로 취급한다.
#
# intersect(x, y): x, y 모두에 있는 관측값만 반환
#
# union(x, y): x 와 y 의 고유한 관측값을 반환
#
# setdiff(x, y): x 에 있지만, y 에 없는 관측값을 반환
#
#
df1 <- tribble(
~x, ~y,
1,  1,
2,  1
)
df2 <- tribble(
~x, ~y,
1,  1,
1,  2
)
intersect(df1, df2)
union(df1, df2)
setdiff(df1, df2)
setdiff(df2, df1)
install.packages("dataRetrieval")
library(dataRetrieval)
library(dataRetrieval)
siteNo <- "05427948"
pCode <- "00060"
start.date <- "2017-10-01"
end.date <- "2018-09-30"
pheasant <- readNWISuv(siteNumbers = siteNo,
parameterCd = pCode,
startDate = start.date,
endDate = end.date)
names(pheasant)
pheasant <- renameNWISColumns(pheasant)
names(pheasant)
names(attributes(pheasant))
url <- attr(pheasant, "url")
url
library(ggplot2)
ts <- ggplot(data = pheasant,
aes(dateTime, Flow_Inst)) +
geom_line()
ts
# Arizona Example
AZ_sites <- whatNWISsites(stateCd = "AZ",
parameterCd = "00665")
nrow(AZ_sites)
names(AZ_sites)
library(ggplot2)
library(ggsn)
library(sf)
library(dplyr)
usa <- st_as_sf(maps::map("state", fill=TRUE, plot =FALSE),
crs = 4269)
sf_az <- st_as_sf(AZ_sites,
coords = c("dec_long_va", "dec_lat_va"),
crs = 4269)
ggplot() +
geom_sf(data = usa[ usa$ID == "arizona" ,]) +
geom_sf(data = sf_az) +
xlab(NULL)+
ylab(NULL)+
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5)) +
north(sf_az, symbol=10, location="bottomleft") +
scalebar(usa[ usa$ID == "arizona" ,],
dist=100, dist_unit="mi", st.size = 3,
transform=TRUE, model="WGS84")
install.packages("ggsn")
install.packages("sf")
library(ggplot2)
library(ggsn)
library(sf)
library(dplyr)
usa <- st_as_sf(maps::map("state", fill=TRUE, plot =FALSE),
crs = 4269)
sf_az <- st_as_sf(AZ_sites,
coords = c("dec_long_va", "dec_lat_va"),
crs = 4269)
ggplot() +
geom_sf(data = usa[ usa$ID == "arizona" ,]) +
geom_sf(data = sf_az) +
xlab(NULL)+
ylab(NULL)+
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5)) +
north(sf_az, symbol=10, location="bottomleft") +
scalebar(usa[ usa$ID == "arizona" ,],
dist=100, dist_unit="mi", st.size = 3,
transform=TRUE, model="WGS84")
# Wisconsin Example
pCode <- c("00665")
phWI <- whatNWISdata(stateCd="WI",
parameterCd=pCode)
library(dplyr)
phWI.1 <- phWI %>%
filter(count_nu > 300) %>%
mutate(period = as.Date(end_date) - as.Date(begin_date)) %>%
filter(period > 15*365)
phos_WI_data <- readNWISqw(siteNumbers = phWI.1$site_no,
parameterCd = pCode)
phos_summary <- phos_WI_data %>%
group_by(site_no) %>%
summarize(max = max(result_va, na.rm = TRUE),
count = n()) %>%
ungroup() %>%
left_join(attr(phos_WI_data, "siteInfo"),
by = "site_no")
View(top_dest)
library(raster);library(tictoc);#library(sp)
setwd('C:/Users/82105/Documents/cellularAutomata/CA_model_OCC_220325')
source('Neighbor_mat_OCC.R');source('STRG_surflow2.R');source('Transition_fun2.R')
asc_file <- raster("clipped_raster_4m_big2.asc")
range_raster <- as.matrix(extent(asc_file))
# x11()
plot(asc_file)
dem <- as.matrix(asc_file$clipped_raster_4m_big2)
dem <- dem - min(dem, na.rm = T)
x_dem <- seq(from=range_raster[1,1], to=range_raster[1,2],length = ncol(dem))
y_dem <- seq(from=range_raster[2,2], to=range_raster[2,1],length = nrow(dem))
min(dem, na.rm = T); max(dem, na.rm = T)
##################################################################################################################################
# Scale transition ###############################################################################################################
##################################################################################################################################
hour_to_sec <- c(3600)
m_to_mm <- c(1000)
cm_to_mm <- c(10)
##################################################################################################################################
# Cellular Automata Setting ######################################################################################################
##################################################################################################################################
##### Time parameter setting for CA calculation
flowdir <- c("D4") # D8, D4, 4+4N
time_step <- c(10) # [seconds] Time step for iteration
time_interval <- c(450) # [seconds] Time interval in observation data
num_col <- ncol(dem); num_row <- nrow(dem)
resolution_cell <- c(floor(res(asc_file))[1]*m_to_mm) #[mm];
sur_dem <- dem*m_to_mm; # [mm]
rownames(sur_dem) <- y_dem;colnames(sur_dem) <- x_dem
sur_waterdepth_dem <- matrix(0, num_row, num_col) # [mm]
rownames(sur_waterdepth_dem) <- y_dem;colnames(sur_waterdepth_dem) <- x_dem
sur_cellheight_dem <- matrix(NA, num_row, num_col) # [mm]
rownames(sur_cellheight_dem) <- y_dem; colnames(sur_cellheight_dem) <- x_dem
sur_storage_dem    <- matrix(NA, num_row, num_col) # [mm]
rownames(sur_storage_dem) <- y_dem; colnames(sur_storage_dem) <- x_dem
theta_Res_Sur_dem    <- matrix(NA, num_row, num_col) # [mm]
rownames(theta_Res_Sur_dem) <- y_dem; colnames(theta_Res_Sur_dem) <- x_dem
theta_Sat_Sur_dem    <- matrix(NA, num_row, num_col) # [mm]
rownames(theta_Sat_Sur_dem) <- y_dem; colnames(theta_Sat_Sur_dem) <- x_dem
Date_data <- c(120928)
hydro_data <- read.csv(paste0('runoffEvent_',Date_data,'_sample.csv'))
hydro_data$Rain <- hydro_data$Rain*10
manning_coeff_sur <- c(0.035);
LAI <- c(3.76) # Leaf Area Index
P_max <- 0.935+0.498*LAI+0.00575*LAI^2 # [mm]
i_init  <- c(2.30) # [mm/hr]
i_final <- c(0.49) # [mm/hr]
i_decay <- c(1.58) # [mm/hr]
Evptr <- c(0)
R_cum <- c(0)
P_pre <- c(0)
Intercep_Total <- c(0)
Infiltra_Total <- c(0)
Runoff_Total <- c(0)
K_Sur=c(0.85);
Depth_Sur=c(5); # Soil depth
E_Sat_Sur_cons_val <- c(0) # % Hydraulic conductivity
E_Sat_Sur=c(0);
E_Sat_Sur_cons = rep(E_Sat_Sur_cons_val, num_row);
dir.create(paste0(getwd(),"/Plot/Plots_",flowdir,time_step,"sec_0",K_Sur*100,'K',E_Sat_Sur_cons_val,'%E_Sat'))
setwd(paste0(getwd(),"/Plot/Plots_",flowdir,time_step,"sec_0",K_Sur*100,'K',E_Sat_Sur_cons_val,'%E_Sat'))
##### Setting for initial conditions of soil texture, water balance ##############################################################
residual_sm_sur <- c(5)
saturated_sm_sur <- c(50)
average_sm_sur <- c(25)
for(j in num_row:1){
for(i in 1:num_col){
if(is.na(dem[j,i])){
next
}
sur_storage_dem[j,i] <- average_sm_sur*Depth_Sur/cm_to_mm
theta_Sat_Sur_dem[j,i] <- saturated_sm_sur*Depth_Sur/cm_to_mm
theta_Res_Sur_dem[j,i] <- residual_sm_sur*Depth_Sur/cm_to_mm
}}
##### Setting for results matrix of runoff time series data ######################################################################
hydro_data <- hydro_data[-1,]
runoff_timeseries <- matrix(NA, 6, nrow(hydro_data));
rownames(runoff_timeseries) <- c('order','obs_runoff[m]','obs_runoff[m/s]','cal_sur_runoff[m]',
'cal_tot_runoff[m]','cal_tot_runoff[m/s]')
runoff_timeseries[1,] <- c(1:nrow(hydro_data))
runoff_timeseries[2,] <- hydro_data$WL # [m]
runoff_timeseries[3,] <- (3*10^(-5))*exp(36.139*hydro_data$WL) # [m3/s]
runoff_timeseries[4:5,1] <- runoff_timeseries[2,1]
runoff_timeseries[6,1] <- runoff_timeseries[3,1]
##### Setting for results matrix of soil moisture time series data ###############################################################
#sur_sm_timeseries <- matrix(NA, nrow(SoilText_Mat)*2, nrow(hydro_data))
#rownames(sur_sm_timeseries) <- c(rownames(SoilText_Mat), paste0("pred_",rownames(SoilText_Mat)))
#sur_sm_timeseries[1:nrow(SoilText_Mat),] <- t(hydro_data[,grep("10", colnames(hydro_data))])
#sur_sm_timeseries[22:42,1] <- sur_sm_timeseries[1:21,1]
time <- c(5)
##################################################################################################################################
# Cellular Automata Calculation ##################################################################################################
##################################################################################################################################
for(time in 1:c(nrow(hydro_data)*time_interval/time_step)){
#for(time in 1:10800){
#tic()
################################################################################################################################
##### Hydrological components ##################################################################################################
################################################################################################################################
##### Rainfall [mm]
R_t <- (hydro_data$Rain[ceiling(time*time_step/time_interval)]/time_interval)*(time_step)
##### Evapotranspiration [mm]
ET_t <- Evptr*(time_step/hour_to_sec)
##### Interception [mm/hr]
R_cum <- R_cum+R_t
P_cum <- P_max*(1-exp(-0.046*LAI*R_cum/P_max))
P_t <- P_cum - P_pre
P_pre <- P_cum
Intercep_Total <- Intercep_Total + P_t
##### Infiltration [mm]
I_t <- (i_final + (i_init-i_final)*exp(-i_decay*time_step/hour_to_sec))*(time_step/hour_to_sec)
Infiltra_Sum <- c(0)
##### Effective rainfall
R_eff <- R_t - P_t - ET_t
################################################################################################################################
##### Set-up for DEM matrix ####################################################################################################
################################################################################################################################
for(y in 1:num_row){
for(x in 1:num_col){
if(is.na(dem[y,x])){
next
}
R_Sur <- sur_storage_dem[y,x] + sur_waterdepth_dem[y,x]
STRG_mat <- STRG_sur2(R_eff, I_t, K_Sur, R_Sur,
E_Sat_Sur_cons[y], Depth_Sur,
theta_Res_Sur_dem[y,x], theta_Sat_Sur_dem[y,x])
sur_storage_dem[y,x] <- STRG_mat[1,1];
sur_waterdepth_dem[y,x] <- STRG_mat[1,2];
Infiltra_Sum <- Infiltra_Sum + STRG_mat[1,3]
}}
sur_waterdepth_dem[nrow(sur_dem),] <- c(0) # discharge at bottom area
sur_waterdepth_dem[1,] <- c(0) # discharge at top area
sur_waterdepth_dem[,ncol(sur_dem)] <- c(0) # discharge at right area
sur_waterdepth_dem[,1] <- c(0) # discharge at left area
Infiltra_Total <- Infiltra_Total + (Infiltra_Sum/(num_row * num_col)) # Infiltration update
sur_cellheight_dem <- sur_dem + sur_storage_dem + sur_waterdepth_dem # Cellheight update
sur_updatecell_dem <- matrix(0, num_row, num_col) # Updatecell update
rownames(sur_updatecell_dem) <- as.numeric(rownames(sur_dem))
colnames(sur_updatecell_dem) <- as.numeric(colnames(sur_dem))
################################################################################################################################
##### Surface flow routing algorithm ###########################################################################################
################################################################################################################################
for(y in 1:num_row){
for(x in 1:num_col){
if(is.na(dem[y,x]) || sur_waterdepth_dem[y,x] <= c(0)){
next
}
sur_neighbor_cell <- matrix(NA, 6, 9);
colnames(sur_neighbor_cell) <- c('upleft','up','upright','left','point','right','doleft','do','doright')
#sur_neighbor_cell[1,] <- c('D','C','D','C','P','C','D','C','D') # C : Cardinal, D : Diagonal
sur_neighbor_cell <- Neighbor_mat(x,y,num_col,num_row,sur_neighbor_cell,
sur_dem,sur_cellheight_dem, sur_waterdepth_dem)
sur_point_cell <- as.matrix(sur_neighbor_cell[,5]); sur_neighbor_cell <- sur_neighbor_cell[,-5]
sur_updatecell_dem <- Transition_fun2(flowdir,manning_coeff_sur,resolution_cell,
time_step,sur_neighbor_cell,sur_point_cell,sur_updatecell_dem)
}}
################################################################################################################################
##### Export PNG file for water depth ##########################################################################################
################################################################################################################################
png(paste0(time_step,"sec_",time,"_plot.png"),width=4000,height=2000,res=200)
# x11()
layout(matrix(c(1,2,3,4), 2, 2, byrow=F))
rast <- raster(sur_dem)
#extent(rast) <- c(c(min(x_dem)+0.5),max(x_dem),c(min(y_dem)+0.5),max(y_dem))
#projection(rast) <- CRS("+proj=longlat +datum=WGS84")
plot(rast, col=terrain.colors(30), main="sur_dem")
rast <- raster(sur_storage_dem)
#extent(rast) <- c(c(min(x_dem)+0.5),max(x_dem),c(min(y_dem)+0.5),max(y_dem))
#projection(rast) <- CRS("+proj=longlat +datum=WGS84")
plot(rast, col=terrain.colors(30), main="sur_Strg")
rast <- raster(sur_waterdepth_dem)
#extent(rast) <- c(c(min(x_dem)+0.5),max(x_dem),c(min(y_dem)+0.5),max(y_dem))
#projection(rast) <- CRS("+proj=longlat +datum=WGS84")
#plot(rast, col=terrain.colors(30), main="sur_waterdepth_dem")
#rast <- raster(sur_updatecell_dem)
#breakpoints <- c(0,200,400,600,800,1000,1200,1400)
#plot(rast,col=terrain.colors(30), main="sur_waterdepth_dem",breaks = breakpoints)
plot(rast, col=terrain.colors(11), main="sur_waterdepth_dem",breaks=c(0,400,800,1200,1600,2000,2400,2800,3200,3600,4000))
rast <- raster(sur_updatecell_dem)
#extent(rast) <- c(c(min(x_dem)+0.5),max(x_dem),c(min(y_dem)+0.5),max(y_dem))
#projection(rast) <- CRS("+proj=longlat +datum=WGS84")
plot(rast, col=terrain.colors(30), main="sur_updatecell_dem")
dev.off()
################################################################################################################################
##### Undating waterdepth and check error ######################################################################################
################################################################################################################################
sur_waterdepth_dem <- sur_updatecell_dem + sur_waterdepth_dem;
if(c(min(sur_waterdepth_dem)+0.0001) < c(0) ){
print("there is negative values in waterdepth")
break
}
# Runoff_Total <-
#   Runoff_Total+(3*10^(-5))*exp(36.139*c(sur_waterdepth_dem[y_str,x_str]/m_to_mm))*time_step # [m3]
################################################################################################################################
##### Write water balance values ###############################################################################################
################################################################################################################################
#if((time*time_step/time_interval) - floor(time*time_step/time_interval) == 0){
##### updating runoff time series
#  runoff_timeseries[4,c(floor(time*time_step/time_interval))] <- c(sur_waterdepth_dem[y_str,x_str])/m_to_mm # [m]
#  runoff_timeseries[5,c(floor(time*time_step/time_interval))] <- c(sur_waterdepth_dem[y_str,x_str])/m_to_mm # [mm]
#  runoff_timeseries[6,c(floor(time*time_step/time_interval))] <-
#                       c(3*10^(-5))*exp(36.139*runoff_timeseries[4,c(floor(time*time_step/time_interval))]) # [m3/s]
##### updating soil moisture time series
#  for(t in 1:c(nrow(sur_sm_timeseries)/2)){
#    sm_y_point <- which.min(abs(SoilText_Mat$y[t] - as.numeric(rownames(sur_cellheight_dem))))
#    sm_x_point <- which.min(abs(SoilText_Mat$x[t] - as.numeric(colnames(sur_cellheight_dem))))
#    sur_sm_timeseries[21+t, c(floor(time*time_step/time_interval))] <-
#                        c(sur_waterdepth_dem[sm_y_point,sm_x_point] + sur_storage_dem[sm_y_point,sm_x_point]) # [mm]
# }
#}
}
Rain_space <- sum((hydro_data$Rain/m_to_mm)*ncol(sur_dem)*(resolution_cell/m_to_mm)*nrow(sur_dem)*(resolution_cell/m_to_mm)) # [m3]
Intercep_space  <-
sum((Intercep_Total/m_to_mm)*ncol(sur_dem)*(resolution_cell/m_to_mm)*nrow(sur_dem)*(resolution_cell/m_to_mm)) # [m3]
Infiltra_space  <-
sum((Infiltra_Total/m_to_mm)*ncol(sur_dem)*(resolution_cell/m_to_mm)*nrow(sur_dem)*(resolution_cell/m_to_mm)) # [m3]
# Runoff_space_cal  <- Runoff_Total # [m3]
# runoff_diff <- runoff_timeseries[2,] - runoff_timeseries[2,1]
# runoff_flowrate <- (3*10^(-5))*exp(36.139*runoff_diff)
# Runoff_space_obs <- sum(runoff_flowrate[runoff_flowrate>0])*length(runoff_diff[runoff_diff>0])*time_interval # [m3]
##################################################################################################################################
# Cellular Automata Outputs ######################################################################################################
##################################################################################################################################
setwd('C:/Users/82105/Documents/cellularAutomata/CA_model_OCC_220325')
water_balance_mat <- matrix(NA, 1, 5)
colnames(water_balance_mat) <- c('Rainfall[m3]','Interception[m3]','Infiltration[m3]',
'Observed runoff[m3]','Calculated runoff[m3]')
water_balance_mat[1,] <- c(round(Rain_space,2),round(Intercep_space,2),round(Infiltra_space,2),
round(Runoff_space_obs,2),round(Runoff_space_cal,2))
write.csv(water_balance_mat,
paste0(getwd(),'/Results/WaterBudget_',time_step,"sec_0",K_Sur*100,'K',E_Sat_Sur_cons_val,'%E_Sat.csv'))
write.csv(runoff_timeseries,
paste0(getwd(),'/Results/runoff_timeseries_',time_step,"sec_0",K_Sur*100,'K',E_Sat_Sur_cons_val,'%E_Sat.csv'))
write.csv(sur_sm_timeseries,
paste0(getwd(),'/Results/sur_sm_timeseries_',time_step,"sec_0",K_Sur*100,'K',E_Sat_Sur_cons_val,'%E_Sat.csv'))
CA_results <-
list("Water_balance_mat"=water_balance_mat,"Runoff_timeseries"=runoff_timeseries,"SM_timeseries"=sur_sm_timeseries)
# toc()
source("~/cellularAutomata/CA_model_OCC_220325/CA_cal_occwatershed_portland_new.R")
source("~/cellularAutomata/CA_model_OCC_220325/CA_cal_occwatershed_portland_new.R")
library(raster);library(tictoc);library(sp)
setwd('C:/Users/82105/Documents/cellularAutomata/CA_model_OCC_220325')
source('Neighbor_mat_OCC.R');source('STRG_surflow2.R');source('Transition_fun2.R')
asc_file <- raster("clipped_raster_4m_big2.asc")
range_raster <- as.matrix(extent(asc_file))
# x11()
plot(asc_file)
dem <- as.matrix(asc_file$clipped_raster_4m_big2)
dem <- dem - min(dem, na.rm = T)
x_dem <- seq(from=range_raster[1,1], to=range_raster[1,2],length = ncol(dem))
y_dem <- seq(from=range_raster[2,2], to=range_raster[2,1],length = nrow(dem))
min(dem, na.rm = T); max(dem, na.rm = T)
##################################################################################################################################
# Scale transition ###############################################################################################################
##################################################################################################################################
hour_to_sec <- c(3600)
m_to_mm <- c(1000)
cm_to_mm <- c(10)
source("~/cellularAutomata/CA_model_OCC_220325/CA_cal_occwatershed_portland_new.R")
source("~/cellularAutomata/CA_model_OCC_220325/CA_cal_occwatershed_portland_new.R")
debugSource("~/cellularAutomata/CA_model_OCC_220325/CA_cal_occwatershed_portland_new.R")
source("~/cellularAutomata/CA_model_OCC_220325/CA_cal_occwatershed_portland_new.R")
source("~/cellularAutomata/CA_model_OCC_220325/CA_cal_occwatershed_portland_new.R")
source("~/cellularAutomata/CA_model_OCC_220325/CA_cal_occwatershed_portland_new.R")
source("~/cellularAutomata/CA_model_OCC_220325/CA_cal_occwatershed_portland_new.R")
source("~/cellularAutomata/CA_model_OCC_220325/CA_cal_occwatershed_portland_new.R")
source("~/cellularAutomata/CA_model_OCC_220325/CA_cal_occwatershed_portland_new.R")
